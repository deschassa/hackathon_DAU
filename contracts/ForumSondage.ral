Contract ForumSondage(
    mut totalProjets: U256
) {
    mapping[U256, ByteVec] titres
    mapping[U256, ByteVec] descriptions 
    mapping[U256, ByteVec] liens        
    mapping[U256, U256] objectifs
    mapping[U256, U256] fondsRecoltes
    mapping[U256, Address] createurs
    mapping[U256, U256] deadlines       
    mapping[U256, Bool] estCloture
    mapping[ByteVec, U256] donsParDonateur 

    event NouveauProjet(id: U256, createur: Address, titre: ByteVec, objectif: U256)
    event DonRecu(id: U256, donateur: Address, montant: U256)
    event FondsRetires(id: U256, createur: Address, montant: U256)
    event Remboursement(id: U256, donateur: Address, montant: U256)

    // ==========================================
    // âœï¸ CRÃ‰ATION DE PROJET
    // ==========================================
    @using(updateFields = true, checkExternalCaller = false, preapprovedAssets = true)
    pub fn creerProjet(
        titre: ByteVec, 
        description: ByteVec,
        liensProjet: ByteVec,       
        objectif: U256,
        dureeEnMs: U256
    ) -> () {
        let id = totalProjets
        titres.insert!(id, titre)
        descriptions.insert!(id, description)
        liens.insert!(id, liensProjet)
        objectifs.insert!(id, objectif)
        fondsRecoltes.insert!(id, 0) 
        createurs.insert!(id, callerAddress!())
        
        let deadline = blockTimeStamp!() + dureeEnMs 
        deadlines.insert!(id, deadline)
        estCloture.insert!(id, false)
        
        totalProjets = totalProjets + 1
        emit NouveauProjet(id, callerAddress!(), titre, objectif)
    }

    // ==========================================
    // ğŸ’¸ FINANCEMENT ET REÃ‡US
    // ==========================================
    @using(updateFields = true, checkExternalCaller = false, preapprovedAssets = true, assetsInContract = true)
    pub fn financerProjet(id: U256, montant: U256) -> () {
        assert!(id < totalProjets, 0) 
        assert!(blockTimeStamp!() < deadlines[id], 1) // âŒ Projet expirÃ© !
        assert!(estCloture[id] == false, 2) // âŒ Projet dÃ©jÃ  fermÃ©
        
        transferTokenToSelf!(callerAddress!(), ALPH, montant)
        fondsRecoltes[id] = fondsRecoltes[id] + montant
        
        // ğŸ§¾ CrÃ©ation du reÃ§u pour un Ã©ventuel remboursement
        let cleRecu = blake2b!(toByteVec!(id) ++ toByteVec!(callerAddress!()))
        if (donsParDonateur.contains!(cleRecu)) {
            donsParDonateur[cleRecu] = donsParDonateur[cleRecu] + montant
        } else {
            donsParDonateur.insert!(cleRecu, montant)
        }

        emit DonRecu(id, callerAddress!(), montant)
    }

    // ==========================================
    // ğŸ† RETRAIT ET ğŸ›¡ï¸ REMBOURSEMENT
    // ==========================================
    @using(updateFields = true, checkExternalCaller = false, assetsInContract = true)
    pub fn retirerFonds(id: U256) -> () {
        assert!(id < totalProjets, 0)
        assert!(estCloture[id] == false, 2) 
        assert!(fondsRecoltes[id] >= objectifs[id], 3) // âŒ Objectif non atteint

        let montant = fondsRecoltes[id]
        estCloture[id] = true 
        
        transferTokenFromSelf!(createurs[id], ALPH, montant)
        emit FondsRetires(id, createurs[id], montant)
    }

    @using(updateFields = true, checkExternalCaller = false, assetsInContract = true)
    pub fn rembourser(id: U256) -> () {
        assert!(id < totalProjets, 0)
        assert!(blockTimeStamp!() >= deadlines[id], 4) // âŒ Le temps n'est pas encore Ã©coulÃ©
        assert!(fondsRecoltes[id] < objectifs[id], 5) // âŒ L'objectif est atteint
        
        let cleRecu = blake2b!(toByteVec!(id) ++ toByteVec!(callerAddress!()))
        assert!(donsParDonateur.contains!(cleRecu), 6) 
        
        let montantARembourser = donsParDonateur[cleRecu]
        assert!(montantARembourser > 0, 7) 
        
        donsParDonateur[cleRecu] = 0 // On dÃ©chire le reÃ§u
        
        transferTokenFromSelf!(callerAddress!(), ALPH, montantARembourser)
        emit Remboursement(id, callerAddress!(), montantARembourser)
    }

    // ==========================================
    // ğŸ‘“ LECTURE (Pour l'interface)
    // ==========================================
    pub fn getTotalProjets() -> U256 { return totalProjets }
    pub fn getTitre(id: U256) -> ByteVec { return titres[id] }
    pub fn getObjectif(id: U256) -> U256 { return objectifs[id] }
    pub fn getFondsRecoltes(id: U256) -> U256 { return fondsRecoltes[id] }
    pub fn getDescription(id: U256) -> ByteVec { return descriptions[id] }
    pub fn getLiens(id: U256) -> ByteVec { return liens[id] }
    pub fn getDeadline(id: U256) -> U256 { return deadlines[id] }
    pub fn getEstCloture(id: U256) -> Bool { return estCloture[id] }
}