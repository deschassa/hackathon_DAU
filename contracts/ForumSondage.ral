Contract ForumSondage(
    mut totalProjets: U256
) {
    // --- VARIABLES DE BASE ---
    mapping[U256, ByteVec] titres
    mapping[U256, ByteVec] descriptions 
    mapping[U256, ByteVec] liens        
    mapping[U256, ByteVec] hashtags     
    mapping[U256, U256] objectifs
    mapping[U256, U256] fondsRecoltes
    mapping[U256, Address] createurs
    mapping[U256, U256] deadlines       
    mapping[ByteVec, U256] donsParDonateur 

    // --- MILESTONES & SÃ‰CURITÃ‰ ---
    mapping[U256, Bool] estAnnule           
    mapping[U256, U256] phasesRetrait       
    mapping[U256, U256] notesPonderees      
    mapping[ByteVec, Bool] aVote            
    mapping[U256, U256] fondsVotants        // âš–ï¸ NOUVEAU: Total des ALPH ayant participÃ© au vote

    // --- PROFILAGE DES INVESTISSEURS (GAMIFICATION) ---
    mapping[Address, U256] profilNbVotes    // ðŸ‘¤ NOUVEAU: Combien de fois ce wallet a votÃ©
    mapping[Address, U256] profilSommeNotes // ðŸ“Š NOUVEAU: Somme totale des notes donnÃ©es

    // --- EVENTS ---
    event NouveauProjet(id: U256, createur: Address, titre: ByteVec)
    event DonRecu(id: U256, donateur: Address, montant: U256)
    event PhaseDebloquee(id: U256, phase: U256, montant: U256)
    event ProjetAnnule(id: U256)
    event VoteEnregistre(id: U256, donateur: Address, note: U256)

    // ==========================================
    // âœï¸ 1. CRÃ‰ATION
    // ==========================================
    @using(updateFields = true, checkExternalCaller = false, preapprovedAssets = true)
    pub fn creerProjet(titre: ByteVec, description: ByteVec, liensProjet: ByteVec, tags: ByteVec, objectif: U256, dureeEnMs: U256) -> () {
        let id = totalProjets
        titres.insert!(id, titre)
        descriptions.insert!(id, description)
        liens.insert!(id, liensProjet)
        hashtags.insert!(id, tags)
        objectifs.insert!(id, objectif)
        fondsRecoltes.insert!(id, 0) 
        createurs.insert!(id, callerAddress!())
        deadlines.insert!(id, blockTimeStamp!() + dureeEnMs)
        
        estAnnule.insert!(id, false)
        phasesRetrait.insert!(id, 0)
        notesPonderees.insert!(id, 0)
        fondsVotants.insert!(id, 0) // Initialisation du quorum
        
        totalProjets = totalProjets + 1
        emit NouveauProjet(id, callerAddress!(), titre)
    }

    // ==========================================
    // ðŸ’¸ 2. FINANCEMENT
    // ==========================================
    @using(updateFields = true, checkExternalCaller = false, preapprovedAssets = true, assetsInContract = true)
    pub fn financerProjet(id: U256, montant: U256) -> () {
        assert!(id < totalProjets, 0) 
        assert!(blockTimeStamp!() < deadlines[id], 1) 
        assert!(estAnnule[id] == false, 2) 
        assert!(phasesRetrait[id] == 0, 3) 
        
        transferTokenToSelf!(callerAddress!(), ALPH, montant)
        fondsRecoltes[id] = fondsRecoltes[id] + montant
        
        let cleRecu = blake2b!(toByteVec!(id) ++ toByteVec!(callerAddress!()))
        if (donsParDonateur.contains!(cleRecu)) {
            donsParDonateur[cleRecu] = donsParDonateur[cleRecu] + montant
        } else {
            donsParDonateur.insert!(cleRecu, montant)
        }
        emit DonRecu(id, callerAddress!(), montant)
    }

    // ==========================================
    // â­ 3. GOUVERNANCE : LE VOTE & PROFILAGE
    // ==========================================
    @using(updateFields = true, checkExternalCaller = false)
    pub fn voterPourPhaseDeux(id: U256, note: U256) -> () {
        assert!(id < totalProjets, 0)
        assert!(phasesRetrait[id] == 1, 4) 
        assert!(note >= 1 && note <= 5, 5) 
        
        let caller = callerAddress!()
        let cleRecu = blake2b!(toByteVec!(id) ++ toByteVec!(caller))
        assert!(donsParDonateur.contains!(cleRecu), 6) 
        assert!(!aVote.contains!(cleRecu), 7) 
        
        aVote.insert!(cleRecu, true)
        
        // 1. Mise Ã  jour des stats du projet
        let poidsVote = donsParDonateur[cleRecu] * note
        notesPonderees[id] = notesPonderees[id] + poidsVote
        fondsVotants[id] = fondsVotants[id] + donsParDonateur[cleRecu] // On ajoute le poids de l'investisseur au quorum
        
        // 2. Mise Ã  jour du Profil de l'investisseur
        if (profilNbVotes.contains!(caller)) {
            profilNbVotes[caller] = profilNbVotes[caller] + 1
            profilSommeNotes[caller] = profilSommeNotes[caller] + note
        } else {
            profilNbVotes.insert!(caller, 1)
            profilSommeNotes.insert!(caller, note)
        }
        
        emit VoteEnregistre(id, caller, note)
    }

    // ==========================================
    // ðŸ† 4. LE RETRAIT EN DEUX TEMPS (MILESTONES)
    // ==========================================
    @using(updateFields = true, checkExternalCaller = false, assetsInContract = true)
    pub fn retirerFonds(id: U256) -> () {
        assert!(callerAddress!() == createurs[id], 8) 
        assert!(estAnnule[id] == false, 2)
        assert!(fondsRecoltes[id] >= objectifs[id], 9) 
        
        let phaseActuelle = phasesRetrait[id]
        let moitieFonds = fondsRecoltes[id] / 2

        if (phaseActuelle == 0) {
            phasesRetrait[id] = 1
            transferTokenFromSelf!(createurs[id], ALPH, moitieFonds)
            emit PhaseDebloquee(id, 1, moitieFonds)
        } else if (phaseActuelle == 1) {
            let scoreRequis = fondsVotants[id] * 3 
            assert!(notesPonderees[id] >= scoreRequis, 10) 
            
            phasesRetrait[id] = 2
            transferTokenFromSelf!(createurs[id], ALPH, moitieFonds)
            emit PhaseDebloquee(id, 2, moitieFonds)
        } else {
            assert!(false, 11) 
        }
    }

    // ==========================================
    // ðŸ›‘ 5. SÃ‰CURITÃ‰ : ANNULATION & REMBOURSEMENT SÃ‰CURISÃ‰
    // ==========================================
    @using(updateFields = true, checkExternalCaller = false)
    pub fn annulerProjet(id: U256) -> () {
        assert!(callerAddress!() == createurs[id], 8)
        assert!(phasesRetrait[id] < 2, 12) 
        estAnnule[id] = true
        emit ProjetAnnule(id)
    }

    @using(updateFields = true, checkExternalCaller = false, assetsInContract = true)
    pub fn rembourser(id: U256) -> () {
        assert!(id < totalProjets, 0)
        
        let tempsEcoule = blockTimeStamp!() >= deadlines[id]
        let objectifRate = fondsRecoltes[id] < objectifs[id]
        
        // ðŸš€ NOUVEAUTÃ‰ : VÃ©rification de l'Ã©chec du vote (Quorum 90% + Note < 3)
        let mut echecVote = false
        if (phasesRetrait[id] == 1) {
            // (fondsVotants * 100) >= (fondsRecoltes * 90) Ã©vite les nombres Ã  virgule !
            let quorumAtteint = (fondsVotants[id] * 100) >= (fondsRecoltes[id] * 90)
            let noteMauvaise = notesPonderees[id] < (fondsVotants[id] * 3)
            echecVote = quorumAtteint && noteMauvaise
        }
        
        // On rembourse si annulÃ©, ou si ratÃ©, OU si le vote a Ã©chouÃ© !
        assert!(estAnnule[id] || (tempsEcoule && objectifRate) || echecVote, 13) 
        
        let cleRecu = blake2b!(toByteVec!(id) ++ toByteVec!(callerAddress!()))
        assert!(donsParDonateur.contains!(cleRecu), 6)
        
        let mut montantARembourser = donsParDonateur[cleRecu]
        assert!(montantARembourser > 0, 14) 
        
        if (phasesRetrait[id] == 1) {
            montantARembourser = montantARembourser / 2
        }
        
        donsParDonateur[cleRecu] = 0 
        transferTokenFromSelf!(callerAddress!(), ALPH, montantARembourser)
    }

    // --- GETTERS (Mise Ã  jour pour le Frontend) ---
    pub fn getTotalProjets() -> U256 { return totalProjets }
    pub fn getTitre(id: U256) -> ByteVec { return titres[id] }
    pub fn getObjectif(id: U256) -> U256 { return objectifs[id] }
    pub fn getFondsRecoltes(id: U256) -> U256 { return fondsRecoltes[id] }
    pub fn getDescription(id: U256) -> ByteVec { return descriptions[id] }
    pub fn getLiens(id: U256) -> ByteVec { return liens[id] }
    pub fn getHashtags(id: U256) -> ByteVec { return hashtags[id] } 
    pub fn getDeadline(id: U256) -> U256 { return deadlines[id] }
    pub fn getEstAnnule(id: U256) -> Bool { return estAnnule[id] } 
    pub fn getPhaseRetrait(id: U256) -> U256 { return phasesRetrait[id] } 
    
    // Nouveaux Getters
    pub fn getFondsVotants(id: U256) -> U256 { return fondsVotants[id] } 
    pub fn getProfilNbVotes(investisseur: Address) -> U256 { 
        if (profilNbVotes.contains!(investisseur)) { return profilNbVotes[investisseur] } 
        else { return 0 }
    }
    pub fn getProfilSommeNotes(investisseur: Address) -> U256 { 
        if (profilSommeNotes.contains!(investisseur)) { return profilSommeNotes[investisseur] } 
        else { return 0 }
    }
}