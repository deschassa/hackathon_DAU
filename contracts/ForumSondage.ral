Contract ForumSondage(
    mut totalProjets: U256
) {
    // --- VARIABLES DE BASE ---
    mapping[U256, ByteVec] titres
    mapping[U256, ByteVec] descriptions 
    mapping[U256, ByteVec] liens        
    mapping[U256, ByteVec] hashtags     
    mapping[U256, U256] objectifs
    mapping[U256, U256] fondsRecoltes
    mapping[U256, Address] createurs
    mapping[U256, U256] deadlines       
    mapping[ByteVec, U256] donsParDonateur 

    // --- ğŸ†• NOUVELLES VARIABLES (MILESTONES & SÃ‰CURITÃ‰) ---
    mapping[U256, Bool] estAnnule           // ğŸš© Si le crÃ©ateur abandonne
    mapping[U256, U256] phasesRetrait       // ğŸ† 0 = Rien, 1 = 50% retirÃ©s, 2 = 100% retirÃ©s
    mapping[U256, U256] notesPonderees      // â­ Somme des (Montant * Note)
    mapping[ByteVec, Bool] aVote            // ğŸ—³ï¸ EmpÃªche le double vote

    // --- EVENTS ---
    event NouveauProjet(id: U256, createur: Address, titre: ByteVec)
    event DonRecu(id: U256, donateur: Address, montant: U256)
    event PhaseDebloquee(id: U256, phase: U256, montant: U256)
    event ProjetAnnule(id: U256)
    event VoteEnregistre(id: U256, donateur: Address, note: U256)

    // ==========================================
    // âœï¸ 1. CRÃ‰ATION
    // ==========================================
    @using(updateFields = true, checkExternalCaller = false, preapprovedAssets = true)
    pub fn creerProjet(titre: ByteVec, description: ByteVec, liensProjet: ByteVec, tags: ByteVec, objectif: U256, dureeEnMs: U256) -> () {
        let id = totalProjets
        titres.insert!(id, titre)
        descriptions.insert!(id, description)
        liens.insert!(id, liensProjet)
        hashtags.insert!(id, tags)
        objectifs.insert!(id, objectif)
        fondsRecoltes.insert!(id, 0) 
        createurs.insert!(id, callerAddress!())
        deadlines.insert!(id, blockTimeStamp!() + dureeEnMs)
        
        // Initialisation de la sÃ©curitÃ©
        estAnnule.insert!(id, false)
        phasesRetrait.insert!(id, 0)
        notesPonderees.insert!(id, 0)
        
        totalProjets = totalProjets + 1
        emit NouveauProjet(id, callerAddress!(), titre)
    }

    // ==========================================
    // ğŸ’¸ 2. FINANCEMENT
    // ==========================================
    @using(updateFields = true, checkExternalCaller = false, preapprovedAssets = true, assetsInContract = true)
    pub fn financerProjet(id: U256, montant: U256) -> () {
        assert!(id < totalProjets, 0) 
        assert!(blockTimeStamp!() < deadlines[id], 1) // âŒ Temps Ã©coulÃ©
        assert!(estAnnule[id] == false, 2) // âŒ Projet annulÃ©
        assert!(phasesRetrait[id] == 0, 3) // âŒ Phase 1 dÃ©jÃ  entamÃ©e, trop tard pour donner
        
        transferTokenToSelf!(callerAddress!(), ALPH, montant)
        fondsRecoltes[id] = fondsRecoltes[id] + montant
        
        let cleRecu = blake2b!(toByteVec!(id) ++ toByteVec!(callerAddress!()))
        if (donsParDonateur.contains!(cleRecu)) {
            donsParDonateur[cleRecu] = donsParDonateur[cleRecu] + montant
        } else {
            donsParDonateur.insert!(cleRecu, montant)
        }
        emit DonRecu(id, callerAddress!(), montant)
    }

    // ==========================================
    // â­ 3. GOUVERNANCE : LE VOTE DES INVESTISSEURS
    // ==========================================
    @using(updateFields = true, checkExternalCaller = false)
    pub fn voterPourPhaseDeux(id: U256, note: U256) -> () {
        assert!(id < totalProjets, 0)
        assert!(phasesRetrait[id] == 1, 4) // âŒ Le vote n'est ouvert qu'aprÃ¨s la Phase 1
        assert!(note >= 1 && note <= 5, 5) // âŒ La note doit Ãªtre entre 1 et 5
        
        let cleRecu = blake2b!(toByteVec!(id) ++ toByteVec!(callerAddress!()))
        assert!(donsParDonateur.contains!(cleRecu), 6) // âŒ Tu n'es pas investisseur
        assert!(!aVote.contains!(cleRecu), 7) // âŒ Tu as dÃ©jÃ  votÃ©
        
        aVote.insert!(cleRecu, true)
        
        // PondÃ©ration : Montant investi * Note
        let poidsVote = donsParDonateur[cleRecu] * note
        notesPonderees[id] = notesPonderees[id] + poidsVote
        
        emit VoteEnregistre(id, callerAddress!(), note)
    }

    // ==========================================
    // ğŸ† 4. LE RETRAIT EN DEUX TEMPS (MILESTONES)
    // ==========================================
    @using(updateFields = true, checkExternalCaller = false, assetsInContract = true)
    pub fn retirerFonds(id: U256) -> () {
        assert!(callerAddress!() == createurs[id], 8) // âŒ Seul le crÃ©ateur retire
        assert!(estAnnule[id] == false, 2)
        assert!(fondsRecoltes[id] >= objectifs[id], 9) // âŒ Objectif non atteint
        
        let phaseActuelle = phasesRetrait[id]
        let moitieFonds = fondsRecoltes[id] / 2

        if (phaseActuelle == 0) {
            // RETRAIT PHASE 1 : On donne 50%
            phasesRetrait[id] = 1
            transferTokenFromSelf!(createurs[id], ALPH, moitieFonds)
            emit PhaseDebloquee(id, 1, moitieFonds)
        } else if (phaseActuelle == 1) {
            // RETRAIT PHASE 2 : VÃ©rification de la moyenne des votes (>= 3/5)
            let scoreRequis = fondsRecoltes[id] * 3 
            assert!(notesPonderees[id] >= scoreRequis, 10) // âŒ Note moyenne insuffisante (< 3/5)
            
            phasesRetrait[id] = 2
            transferTokenFromSelf!(createurs[id], ALPH, moitieFonds)
            emit PhaseDebloquee(id, 2, moitieFonds)
        } else {
            assert!(false, 11) // âŒ Tout a dÃ©jÃ  Ã©tÃ© retirÃ©
        }
    }

    // ==========================================
    // ğŸ›‘ 5. SÃ‰CURITÃ‰ : ANNULATION & REMBOURSEMENT
    // ==========================================
    @using(updateFields = true, checkExternalCaller = false)
    pub fn annulerProjet(id: U256) -> () {
        assert!(callerAddress!() == createurs[id], 8)
        assert!(phasesRetrait[id] < 2, 12) // Impossible d'annuler si tout est retirÃ©
        estAnnule[id] = true
        emit ProjetAnnule(id)
    }

    @using(updateFields = true, checkExternalCaller = false, assetsInContract = true)
    pub fn rembourser(id: U256) -> () {
        assert!(id < totalProjets, 0)
        
        // On peut rembourser SI le projet est annulÃ© OU SI (le temps est Ã©coulÃ© ET l'objectif a ratÃ©)
        let tempsEcoule = blockTimeStamp!() >= deadlines[id]
        let objectifRate = fondsRecoltes[id] < objectifs[id]
        assert!(estAnnule[id] || (tempsEcoule && objectifRate), 13) 
        
        let cleRecu = blake2b!(toByteVec!(id) ++ toByteVec!(callerAddress!()))
        assert!(donsParDonateur.contains!(cleRecu), 6)
        
        let mut montantARembourser = donsParDonateur[cleRecu]
        assert!(montantARembourser > 0, 14) // âŒ DÃ©jÃ  remboursÃ©
        
        // Si le crÃ©ateur a dÃ©jÃ  pris la Phase 1 (50%), on ne peut rendre que les 50% restants
        if (phasesRetrait[id] == 1) {
            montantARembourser = montantARembourser / 2
        }
        
        donsParDonateur[cleRecu] = 0 // On dÃ©chire le reÃ§u
        transferTokenFromSelf!(callerAddress!(), ALPH, montantARembourser)
    }

    // --- GETTERS ---
    pub fn getTotalProjets() -> U256 { return totalProjets }
    pub fn getTitre(id: U256) -> ByteVec { return titres[id] }
    pub fn getObjectif(id: U256) -> U256 { return objectifs[id] }
    pub fn getFondsRecoltes(id: U256) -> U256 { return fondsRecoltes[id] }
    pub fn getDescription(id: U256) -> ByteVec { return descriptions[id] }
    pub fn getLiens(id: U256) -> ByteVec { return liens[id] }
    pub fn getHashtags(id: U256) -> ByteVec { return hashtags[id] } 
    pub fn getDeadline(id: U256) -> U256 { return deadlines[id] }
    pub fn getEstAnnule(id: U256) -> Bool { return estAnnule[id] } // ğŸ†•
    pub fn getPhaseRetrait(id: U256) -> U256 { return phasesRetrait[id] } // ğŸ†•
}