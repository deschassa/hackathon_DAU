Contract ForumSondage(
    mut totalProjets: U256
) {
    mapping[U256, ByteVec] titres
    mapping[U256, U256] objectifs
    mapping[U256, U256] fondsRecoltes
    mapping[U256, Address] createurs
    
    // â³ NOUVEAU : Gestion du temps et du statut
    mapping[U256, U256] deadlines 
    mapping[U256, Bool] estCloture 
    
    // ğŸ’¸ NOUVEAU : On garde une trace de qui a donnÃ© combien pour les remboursements
    mapping[ByteVec, U256] donsParDonateur

    event NouveauProjet(id: U256, createur: Address, titre: ByteVec, objectif: U256, deadline: U256)
    event DonRecu(id: U256, donateur: Address, montant: U256)
    event FondsRetires(id: U256, createur: Address, montant: U256)
    event Remboursement(id: U256, donateur: Address, montant: U256)

    @using(updateFields = true, checkExternalCaller = false, preapprovedAssets = true)
    pub fn creerProjet(titre: ByteVec, objectif: U256) -> () {
        let id = totalProjets
        titres.insert!(id, titre)
        objectifs.insert!(id, objectif)
        fondsRecoltes.insert!(id, 0) 
        createurs.insert!(id, callerAddress!())
        
        // â³ 5 minutes = 300 000 millisecondes (pour les tests)
        let deadline = blockTimeStamp!() + 300000 
        deadlines.insert!(id, deadline)
        estCloture.insert!(id, false)
        
        totalProjets = totalProjets + 1
        emit NouveauProjet(id, callerAddress!(), titre, objectif, deadline)
    }

    @using(updateFields = true, checkExternalCaller = false, preapprovedAssets = true, assetsInContract = true)
    pub fn financerProjet(id: U256, montant: U256) -> () {
        assert!(id < totalProjets, 0)
        assert!(blockTimeStamp!() < deadlines[id], 1) // âŒ Projet expirÃ© !
        assert!(estCloture[id] == false, 2) // âŒ Projet dÃ©jÃ  fermÃ©

        // On prend l'argent
        transferTokenToSelf!(callerAddress!(), ALPH, montant)
        fondsRecoltes[id] = fondsRecoltes[id] + montant
        
        // On crÃ©e un reÃ§u unique (ID du projet + Adresse du donateur)
        let cleRecu = blake2b!(toByteVec!(id) ++ toByteVec!(callerAddress!()))
        
        // On met Ã  jour le reÃ§u du donateur
        if (donsParDonateur.contains!(cleRecu)) {
            donsParDonateur[cleRecu] = donsParDonateur[cleRecu] + montant
        } else {
            donsParDonateur.insert!(cleRecu, montant)
        }

        emit DonRecu(id, callerAddress!(), montant)
    }

    // ğŸ† LE CRÃ‰ATEUR RÃ‰CUPÃˆRE L'ARGENT SI SUCCÃˆS
    @using(updateFields = true, checkExternalCaller = false, assetsInContract = true)
    pub fn retirerFonds(id: U256) -> () {
        assert!(id < totalProjets, 0)
        assert!(estCloture[id] == false, 2) // âŒ DÃ©jÃ  retirÃ©
        assert!(fondsRecoltes[id] >= objectifs[id], 3) // âŒ Objectif non atteint

        let montant = fondsRecoltes[id]
        estCloture[id] = true // On ferme la caisse
        
        transferTokenFromSelf!(createurs[id], ALPH, montant)
        emit FondsRetires(id, createurs[id], montant)
    }

    // ğŸ›¡ï¸ LES DONATEURS RÃ‰CUPÃˆRENT L'ARGENT SI Ã‰CHEC + TEMPS DÃ‰PASSÃ‰
    @using(updateFields = true, checkExternalCaller = false, assetsInContract = true)
    pub fn rembourser(id: U256) -> () {
        assert!(id < totalProjets, 0)
        assert!(blockTimeStamp!() >= deadlines[id], 4) // âŒ Le temps n'est pas encore Ã©coulÃ©
        assert!(fondsRecoltes[id] < objectifs[id], 5) // âŒ L'objectif est atteint, pas de remboursement possible !
        
        let cleRecu = blake2b!(toByteVec!(id) ++ toByteVec!(callerAddress!()))
        assert!(donsParDonateur.contains!(cleRecu), 6) // âŒ Vous n'avez pas donnÃ© Ã  ce projet
        
        let montantARembourser = donsParDonateur[cleRecu]
        assert!(montantARembourser > 0, 7) // âŒ DÃ©jÃ  remboursÃ©
        
        donsParDonateur[cleRecu] = 0 // On dÃ©chire le reÃ§u pour Ã©viter le double remboursement
        
        transferTokenFromSelf!(callerAddress!(), ALPH, montantARembourser)
        emit Remboursement(id, callerAddress!(), montantARembourser)
    }

    // --- GETTERS ---
    pub fn getTotalProjets() -> U256 { return totalProjets }
    pub fn getTitre(id: U256) -> ByteVec { return titres[id] }
    pub fn getObjectif(id: U256) -> U256 { return objectifs[id] }
    pub fn getFondsRecoltes(id: U256) -> U256 { return fondsRecoltes[id] }
    pub fn getDeadline(id: U256) -> U256 { return deadlines[id] }
    pub fn getEstCloture(id: U256) -> Bool { return estCloture[id] }
}