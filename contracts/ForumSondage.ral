Contract ForumSondage(
    mut totalProjets: U256
) {
    // ==========================================
    // üóÉÔ∏è BASES DE DONN√âES (MAPPINGS)
    // ==========================================
    
    // --- 1. Projets ---
    mapping[U256, ByteVec] titres
    mapping[U256, ByteVec] descriptions 
    mapping[U256, ByteVec] liens        
    mapping[U256, ByteVec] hashtags     
    mapping[U256, U256] objectifs
    mapping[U256, U256] fondsRecoltes
    mapping[U256, Address] createurs
    mapping[U256, U256] deadlines       
    mapping[ByteVec, U256] donsParDonateur 

    // --- 2. Milestones & S√©curit√© ---
    mapping[U256, Bool] estAnnule           
    mapping[U256, U256] phasesRetrait       
    mapping[U256, U256] notesPonderees      
    mapping[ByteVec, Bool] aVote            
    mapping[U256, U256] fondsVotants        

    // --- 3. Profils Investisseurs (Gamification) ---
    mapping[Address, U256] profilNbVotes    
    mapping[Address, U256] profilSommeNotes 

    // --- 4. Profils Cr√©ateurs (Annuaire de Confiance) ---
    mapping[Address, ByteVec] devNoms
    mapping[Address, ByteVec] devCommentaires
    mapping[Address, ByteVec] devEmails
    mapping[Address, U256] devGlobalNotes    // ‚≠ê Somme des notes sur tous les projets du dev
    mapping[Address, U256] devGlobalPoids    // ‚öñÔ∏è Somme du quorum sur tous les projets du dev

    // ==========================================
    // üì¢ EVENTS (NOTIFICATIONS)
    // ==========================================
    event NouveauProjet(id: U256, createur: Address, titre: ByteVec)
    event DonRecu(id: U256, donateur: Address, montant: U256)
    event PhaseDebloquee(id: U256, phase: U256, montant: U256)
    event ProjetAnnule(id: U256)
    event VoteEnregistre(id: U256, donateur: Address, note: U256)

    // ==========================================
    // üë®‚Äçüíª FONCTION 0 : INITIALISER SON PROFIL CR√âATEUR
    // ==========================================
    @using(updateFields = true, checkExternalCaller = false)
    pub fn mettreAJourProfilDev(nom: ByteVec, commentaire: ByteVec, email: ByteVec) -> () {
        let caller = callerAddress!()
        devNoms.insert!(caller, nom)
        devCommentaires.insert!(caller, commentaire)
        devEmails.insert!(caller, email)
        
        // Initialisation des jauges de r√©putation si c'est la premi√®re fois
        if (!devGlobalNotes.contains!(caller)) {
            devGlobalNotes.insert!(caller, 0)
            devGlobalPoids.insert!(caller, 0)
        }
    }

    // ==========================================
    // ‚úçÔ∏è FONCTION 1 : CR√âATION DU PROJET
    // ==========================================
    @using(updateFields = true, checkExternalCaller = false, preapprovedAssets = true)
    pub fn creerProjet(titre: ByteVec, description: ByteVec, liensProjet: ByteVec, tags: ByteVec, objectif: U256, dureeEnMs: U256) -> () {
        let id = totalProjets
        titres.insert!(id, titre)
        descriptions.insert!(id, description)
        liens.insert!(id, liensProjet)
        hashtags.insert!(id, tags)
        objectifs.insert!(id, objectif)
        fondsRecoltes.insert!(id, 0) 
        createurs.insert!(id, callerAddress!())
        deadlines.insert!(id, blockTimeStamp!() + dureeEnMs)
        
        estAnnule.insert!(id, false)
        phasesRetrait.insert!(id, 0)
        notesPonderees.insert!(id, 0)
        fondsVotants.insert!(id, 0) 
        
        totalProjets = totalProjets + 1
        emit NouveauProjet(id, callerAddress!(), titre)
    }

    // ==========================================
    // üí∏ FONCTION 2 : FINANCEMENT
    // ==========================================
    @using(updateFields = true, checkExternalCaller = false, preapprovedAssets = true, assetsInContract = true)
    pub fn financerProjet(id: U256, montant: U256) -> () {
        assert!(id < totalProjets, 0) 
        assert!(blockTimeStamp!() < deadlines[id], 1) 
        assert!(estAnnule[id] == false, 2) 
        assert!(phasesRetrait[id] == 0, 3) 
        
        transferTokenToSelf!(callerAddress!(), ALPH, montant)
        fondsRecoltes[id] = fondsRecoltes[id] + montant
        
        let cleRecu = blake2b!(toByteVec!(id) ++ toByteVec!(callerAddress!()))
        if (donsParDonateur.contains!(cleRecu)) {
            donsParDonateur[cleRecu] = donsParDonateur[cleRecu] + montant
        } else {
            donsParDonateur.insert!(cleRecu, montant)
        }
        emit DonRecu(id, callerAddress!(), montant)
    }

    // ==========================================
    // ‚≠ê FONCTION 3 : GOUVERNANCE & R√âPUTATION
    // ==========================================
    @using(updateFields = true, checkExternalCaller = false)
    pub fn voterPourPhaseDeux(id: U256, note: U256) -> () {
        assert!(id < totalProjets, 0)
        assert!(phasesRetrait[id] == 1, 4) 
        assert!(note >= 1 && note <= 5, 5) 
        
        let caller = callerAddress!()
        let cleRecu = blake2b!(toByteVec!(id) ++ toByteVec!(caller))
        assert!(donsParDonateur.contains!(cleRecu), 6) 
        assert!(!aVote.contains!(cleRecu), 7) 
        
        aVote.insert!(cleRecu, true)
        
        let montantInvesti = donsParDonateur[cleRecu]
        let poidsVote = montantInvesti * note
        let dev = createurs[id]
        
        // 1. Mise √† jour des stats du projet
        notesPonderees[id] = notesPonderees[id] + poidsVote
        fondsVotants[id] = fondsVotants[id] + montantInvesti 
        
        // 2. Mise √† jour de la r√©putation globale du D√©veloppeur (S'il a un profil)
        if (devGlobalNotes.contains!(dev)) {
            devGlobalNotes[dev] = devGlobalNotes[dev] + poidsVote
            devGlobalPoids[dev] = devGlobalPoids[dev] + montantInvesti
        }
        
        // 3. Mise √† jour du Profil de l'Investisseur
        if (profilNbVotes.contains!(caller)) {
            profilNbVotes[caller] = profilNbVotes[caller] + 1
            profilSommeNotes[caller] = profilSommeNotes[caller] + note
        } else {
            profilNbVotes.insert!(caller, 1)
            profilSommeNotes.insert!(caller, note)
        }
        
        emit VoteEnregistre(id, caller, note)
    }

    // ==========================================
    // üèÜ FONCTION 4 : LE RETRAIT (MILESTONES)
    // ==========================================
    @using(updateFields = true, checkExternalCaller = false, assetsInContract = true)
    pub fn retirerFonds(id: U256) -> () {
        assert!(callerAddress!() == createurs[id], 8) 
        assert!(estAnnule[id] == false, 2)
        assert!(fondsRecoltes[id] >= objectifs[id], 9) 
        
        let phaseActuelle = phasesRetrait[id]
        let moitieFonds = fondsRecoltes[id] / 2

        if (phaseActuelle == 0) {
            phasesRetrait[id] = 1
            transferTokenFromSelf!(createurs[id], ALPH, moitieFonds)
            emit PhaseDebloquee(id, 1, moitieFonds)
        } else if (phaseActuelle == 1) {
            let scoreRequis = fondsVotants[id] * 3 
            assert!(notesPonderees[id] >= scoreRequis, 10) 
            
            phasesRetrait[id] = 2
            transferTokenFromSelf!(createurs[id], ALPH, moitieFonds)
            emit PhaseDebloquee(id, 2, moitieFonds)
        } else {
            assert!(false, 11) 
        }
    }

    // ==========================================
    // üõë FONCTION 5 : S√âCURIT√â & REMBOURSEMENT
    // ==========================================
    @using(updateFields = true, checkExternalCaller = false)
    pub fn annulerProjet(id: U256) -> () {
        assert!(callerAddress!() == createurs[id], 8)
        assert!(phasesRetrait[id] < 2, 12) 
        estAnnule[id] = true
        emit ProjetAnnule(id)
    }

    @using(updateFields = true, checkExternalCaller = false, assetsInContract = true)
    pub fn rembourser(id: U256) -> () {
        assert!(id < totalProjets, 0)
        
        let tempsEcoule = blockTimeStamp!() >= deadlines[id]
        let objectifRate = fondsRecoltes[id] < objectifs[id]
        
        let mut echecVote = false
        if (phasesRetrait[id] == 1) {
            let quorumAtteint = (fondsVotants[id] * 100) >= (fondsRecoltes[id] * 90)
            let noteMauvaise = notesPonderees[id] < (fondsVotants[id] * 3)
            echecVote = quorumAtteint && noteMauvaise
        }
        
        assert!(estAnnule[id] || (tempsEcoule && objectifRate) || echecVote, 13) 
        
        let cleRecu = blake2b!(toByteVec!(id) ++ toByteVec!(callerAddress!()))
        assert!(donsParDonateur.contains!(cleRecu), 6)
        
        let mut montantARembourser = donsParDonateur[cleRecu]
        assert!(montantARembourser > 0, 14) 
        
        if (phasesRetrait[id] == 1) {
            montantARembourser = montantARembourser / 2
        }
        
        donsParDonateur[cleRecu] = 0 
        transferTokenFromSelf!(callerAddress!(), ALPH, montantARembourser)
    }

    // ==========================================
    // üîç GETTERS (LECTURE DES DONN√âES)
    // ==========================================
    pub fn getTotalProjets() -> U256 { return totalProjets }
    pub fn getTitre(id: U256) -> ByteVec { return titres[id] }
    pub fn getObjectif(id: U256) -> U256 { return objectifs[id] }
    pub fn getFondsRecoltes(id: U256) -> U256 { return fondsRecoltes[id] }
    pub fn getDescription(id: U256) -> ByteVec { return descriptions[id] }
    pub fn getLiens(id: U256) -> ByteVec { return liens[id] }
    pub fn getHashtags(id: U256) -> ByteVec { return hashtags[id] } 
    pub fn getDeadline(id: U256) -> U256 { return deadlines[id] }
    pub fn getEstAnnule(id: U256) -> Bool { return estAnnule[id] } 
    pub fn getPhaseRetrait(id: U256) -> U256 { return phasesRetrait[id] } 
    pub fn getFondsVotants(id: U256) -> U256 { return fondsVotants[id] } 
    pub fn getCreateur(id: U256) -> Address { return createurs[id] }

    // --- Getters : Profil Investisseur ---
    pub fn getProfilNbVotes(investisseur: Address) -> U256 { 
        if (profilNbVotes.contains!(investisseur)) { return profilNbVotes[investisseur] } 
        else { return 0 }
    }
    pub fn getProfilSommeNotes(investisseur: Address) -> U256 { 
        if (profilSommeNotes.contains!(investisseur)) { return profilSommeNotes[investisseur] } 
        else { return 0 }
    }

    // --- Getters : Profil Cr√©ateur ---
    pub fn getDevNom(dev: Address) -> ByteVec { 
        if (devNoms.contains!(dev)) { return devNoms[dev] }
        else { return b`Anonyme` }
    }
    pub fn getDevCommentaire(dev: Address) -> ByteVec { 
        if (devCommentaires.contains!(dev)) { return devCommentaires[dev] }
        else { return b`Pas de description` }
    }
    pub fn getDevEmail(dev: Address) -> ByteVec { 
        if (devEmails.contains!(dev)) { return devEmails[dev] }
        else { return b`` }
    }
    pub fn getDevReputation(dev: Address) -> (U256, U256) {
        if (devGlobalNotes.contains!(dev)) { return devGlobalNotes[dev], devGlobalPoids[dev] }
        else { return 0, 0 } // Retourne (NotesTotales, QuorumTotal) pour calculer la moyenne c√¥t√© React
    }
}